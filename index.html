<!DOCTYPE HTML>

<html>

<link rel="stylesheet" type="text/css" href="bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="bottstrap.theme.min.css">
<link rel="stylesheet" type="text/css" href="dothtml.ui.css">
<link rel="stylesheet" type="text/css" href="./prettify.css">
<link rel="stylesheet" type="text/css" href="style.css">

<script src="jquery.js"></script>
<script src="bootstrap.min.js"></script>
<script src="dothtml.js"></script>
<script src="dotcss.js"></script>
<script src="dothtml.ui.js"></script>
<script src="beautify-html.js"></script>

<style>
	.blue-italics{
		color: blue;
		font-style: italic;
	}
	.e1btn{
		padding: 5px;
	}
</style>

<body></body>

<script>

var rpsCounter = -1;

function beautifyHtml(source) {

	var opts = {};

	opts.indent_size = 2;
	opts.indent_char = " ";
	opts.max_preserve_newlines = "0"; //Change to -1 to remove all new lines.
	opts.preserve_newlines = opts.max_preserve_newlines !== "-1";
	opts.keep_array_indentation = false;
	opts.break_chained_methods = false;
	opts.indent_scripts = "normal";
	opts.brace_style = "collapse";
	opts.space_before_conditional = true;
	opts.unescape_strings = false;
	opts.jslint_happy = false; //Don't know what this is.
	opts.end_with_newline = false;
	opts.wrap_line_length = 30; //Numb chars before line wrap. 0 = no wrap.
	opts.indent_inner_html = false;
	opts.comma_first = false;
	opts.e4x = false;
	
	var source2 = "";
	
	for(var i = 0; i < source.length; i++){
		switch(source[i]){
			case "<":
				source2 += "\r\n";
				source2 += source[i];
				break;
			case ">":
				source2 += source[i];
				source2 += "\r\n";
				break;
			default: 
				source2 += source[i];
				break;
		}
	}
	
	return html_beautify(source2, opts);
}

//Define a bunch of widgets that will be used in examples.

dot.createWidget ("robotface", function(id, color){
	return dot.div(dot
		.div().style(dotcss.position("absolute").width(10).height(10).left(10).top(10).backgroundColor(0))
		.div().style(dotcss.position("absolute").width(10).height(10).left(10).top(10).backgroundColor(0))
		.div().style(dotcss.position("absolute").width(48).height(5).left(8).top(48).backgroundColor(0))
		.div().style(dotcss.position("absolute").width(64).height(64).display("InlineBlock").backgroundColor(color))
	).id(id).style(dotcss.position("relative").width(64).height(64).backgroundColor(color).display("InlineBlock"));
});

dot.createWidget("featurepreview", function(imageurl, title){
	return dot.div(
		dot.div().class("featurepreview-img")
			.style(dotcss.whiteSpace("nowrap").backgroundImage(imageurl))
		.div(title).class("featurepreview-title")).class("featurepreview")
});

dot.createWidget("showcasesite", function(title, url, preview){
	return dot
		.div()
		.title(title)
		.onclick(function(){
			window.open(url);
		})
		.style(
			dotcss
			.display("inline-block")
			.verticalAlign("bottom")
			.width(200)
			.height(200)
			.backgroundImage(preview)
			.backgroundSize(200)
			.cursor("pointer")
		);
});

dot.globalExampleNumber = 0; //Note: storing global widget vars inside dot is possible, but isn't standardized by any means.
dot.createWidget("featuretutorial", function(title, description, innerDotFunction, afterNotes){
	var exampleNumb = dot.globalExampleNumber;
	var innerDotFunctionStr = innerDotFunction.toString();
	dot.globalExampleNumber++;
	return dot
	.div(
		dot.h3(title)
		.p(description).style(dotcss.padding(2))
		.button("Run example").type("button").style(dotcss.padding(2).color(0xFFFFFF).fontWeight("bold").backgroundColor(0x7799DD).borderRadius(3))
		.onclick(function(event){
			//Empty first. Even though rendering can typically happen right after empty(), 
			//the very first example renders to the target early, meaning the empty will
			//delete the child nodes as soon as it's called (for that example).
			dot("#example" + exampleNumb + "htmlout").empty();
			dot("#example" + exampleNumb + "output").empty(); 
			var result = innerDotFunction();
			//console.log(result);
			dot("#example" + exampleNumb + "htmlout").pre(dot.t(beautifyHtml(result.toString())));
			dot("#example" + exampleNumb + "output").h(result);
		})
		.div(
			dot
			.div(
				dot.pre(dot.t(innerDotFunctionStr.substring(20, innerDotFunctionStr.length - 2))).class("prettyprint linenums")
			).style(dotcss.display("inline-block").whiteSpace("normal").verticalAlign("top").widthP(50).padding(2))
			.div().id("example" + exampleNumb + "htmlout").style(dotcss.display("inline-block").whiteSpace("normal").verticalAlign("top").widthP(25).padding(2))
			.div().id("example" + exampleNumb + "output").style(dotcss.display("inline-block").whiteSpace("normal").verticalAlign("top").widthP(25).padding(2))
		).style(dotcss.widthP(100).whiteSpace("nowrap"))
		.if(afterNotes, dot.p(afterNotes).style(dotcss.padding(2)))
	).style(dotcss.widthP(100).border("2px solid black").padding(2));
});

dot("body")
.div("&copy;2016 - Joshua Sideris").style(dotcss.position("fixed").right(10).bottom(10).color(0x9638527).lineHeight(20))
.div(dot
	.div(
		dot.div("&lt;").id("logoopenningangularbracket").wait(1000, function(){
			return dot.$hide(500);
		})
		.div(
			dot.wait(1500, function(){
				return dot.$show(300, function(){
					return dot.wait(500, function(){
						return dot.$animate({width: 256, height: 256, marginTop: 0}, 500, "swing", dot.h("DOT"));
					});
				});
			})
		).id("logodotsmall").style(dotcss.display("none").marginTop(80))
		.div("html").id("logohtml")
		.div("&gt;").id("logoclosingangularbracket").wait(1000, function(){
			return dot.$hide(500);
		})
	).id("logo")
	.br()
	.br()
	.div("A human-friendly way to build highly-dynamic web pages in pure JavaScript.").id("slogan").$css("opacity", "0.1").wait(3000, function(){
		return dot.$animate({opacity: 1}, 500, "swing");
	})
).id("header")
	.div(
	dot.tabs(
		[
			dot.tab("DOT html", "main",
				dot.div(
					dot.div("Become the most productive programmer on the dynamic web.")
					.br()
					.a("Download DOThtml").href("https://github.com/JSideris/DOThtml/releases").target("_blank").class("download-dot-button")//.download()
				).id("download-dot-banner")
				.hr()
					.h1("DOThtml - The best open-source client-side page buider.")
						.featurepreview("images/smallerpages.png", "Reduces page sizes and load times.")
						.featurepreview("images/helloworld.png", "Prototype faster with succinct, minimalist markup.")
						.featurepreview("images/lotsoffeatures.png", "Supports conditional, iterative, or delayed elements.")
						.featurepreview("images/fasterservers.png", "100% client-side. Reduces server-side load and dependencies.")
						.featurepreview("images/buildonjs.png", "Built in JavaScript. Works on virtually all browsers.")
						.featurepreview("images/extensible.png", "Built for extensibility.")
				.hr()
					.h1("Check out a few sites built with DOThtml.")
						.div(
							DOT
							.showcasesite("JSideris' Home Page", "http://jsideris.com", "./images/jsweb.png")
							.showcasesite("KSP Advanced Mission Planner", "http://jsideris.github.io/AdvancedKspMissionCalculator/", "./images/kspadvancedmissionplanner.png")
							.showcasesite("DOThtml Home", "http://jsideris.github.io/DOThtml/", "./images/dothtmlpreview.png")
						).class("showcase-site-list")
				//.featurepreview("", "Lots of fun to use!")
			), 
			dot.tab("Getting Started", "start",
				dot.h1("Getting Started")
				.h2("Download")
				.div(
					dot
					.div("Download version 1.1.0").style(dotcss.position("absolute").left(0).widthP(50))
					.div("Or get it on GitHub").style(dotcss.position("absolute").right(0).widthP(50))
				).style(dotcss.position("relative").width("100%").height(32))
				.h2("Learn")
				.h("TODO: Insert tutorial video here.")
				.h2("Basic Usage")
				
				.featuretutorial(
					"Building & Rendering Markup", 
					dot.h("Use the <code>dot(target)</code> to render DOT syntax to HTML. <code>target</code> is the CSS selector for the target element(s) to which the rendered markup will be appended. Support for querying multiple targets will be added in a future version of DOThtml. <code>dot(target)</code> returns a chainable <i>page building object</i> containing many <i>page building functions</i> that wrap each HTML tag, attribute, and more!").br().br()
					.h("There are also special chainable building functions for printing out pure HTML markup (<code>h(markup)</code>), or HTML-escaped text nodes (<code>t(text)</code>). We'll start off with an obligatory hello world example."), 
function(){
return dot("#example0output")
.h("<b>Hello,</b>")
.t("<b>world!</b>");
},
					dot.h("<code>dot(target)</code> can be used as a function if you intend to render the resultant HTML to a specific target. However, the name <code>dot</code> is more than just a function. It is also an instance of DOThtml's page building object, and has access to all of the page building functions. This is useful for building nested elements where you don't need to explicitly state a render target (as we'll do in the next example).").br().br()
					.h("This tutorial is designed such that the page building object for each tutorial segment's code is a nested component of a tutorial widget, so the other tutorials will not use <code>dot</code> as a function as you normally would once at the top of your code.")
				)
				.featuretutorial(
					"HTML Building",
					dot.h("In this example we'll render some real HTML elements with attributes to build a mini webpage. DOThtml's syntax went through many iterations as well as testing on real websites to ensure that the final product feels like a light-weight, functional improvement over HTML."),
function(){
return dot.h4("Example 2")
.div(
    dot
    .p("Paragraph 1").style("font-weight: bold; float: left;")
    .p("Paragraph 2").class("blue-italics").style("float: right;")
)
.br().clear("all")
.button("Click Me").type("button").class("e1btn")
.onclick("alert('You clicked the button!');");
},
					dot.h("Note that attributes in DOThtml have the exact same syntax as elements. Any number of attributes can be chained together after an element, and those attributes will attach themselves to the preceeding erlement.").br().br()
					.h("There are five attributes in HTML that have the same name as an element: <code>cite</code>, <code>form</code>, <code>label</code>, <code>span</code>, <code>summary</code>. DOThtml is smart enough to determine from context whether you intended to use these functions to produce an element or to produce an attribute. There are also explicit wrappers for these five names that force DOThtml to explicitly produce an element or to produce an attribute regardless of context. Just add an A or an E to the name of the page building function. For instance: <code>dot.div().formA(value)</code> will explicitly add a form attribute to the div, even though this is erroneous. Since the extended documentation for DOThtml is currently in progress, please refer to the source code (or contact the developer) for more info on contextual element/attribute selection.").br().br()
					.h("<code>accept-charset</code> is currently the only hyphenated HTML attribute (with the exception of custom, or special attributes like <code>data-*</code>). To add a <code>accept-charset</code>, use the <code>acceptcharset(value)</code> function. The <code>data-*</code> attribute can be added to an element using the <code>data(suffix, value)</code> function. This is the only native DOThtml attribute function that accepts two parameters.")
				)
				.featuretutorial("Advanced Building Tools & Nesting",
					dot.h("In DOThtml, element building functions can accept a variety of different things as parameters. Omitting a parameter or passing in <code>null</code>, or <code>undefined</code>, will leave the new element empty. A string argument will typically result in that string being parsed as HTML inside the new element's innerHTML. Any DOT page building object can be used as arguments to create a nested element with pure DOThtml syntax. Arrays will render as a concatenation of recursively rendered elements. Finally, any functions passed into any element functions will be evaluated and DOThtml will attemp to recursively use their return values to build markup.").br().br()
					.h("Attribute building functions typically accept a string value. If no string is passed to an attribute, the attribute name will be used as it's value. This is typical for void attributes, like <code>enabled</code>. <code>dot.input().enabled()</code> will generate <code>").t("<input enabled=\"enabled\" />").h("</code>. Attribute building functions can also accept functions. ").br().br()
					.h("Attribute building functions will attempt to call the <code>toString()</code> function on unknown objects, however, the behavior of element building functions on unknown objects has not been formalized; for now unsupported objects (anything that's not a DOThtml page building object, a function, or an array) will be ignored.").br().br()
					.h("Avoid passing in values to void elements, like <code>img</code> or <code>br</code>."),
function(){
return dot.h4("DOThtml joins processed array elements, and...")
.ul([
    "<li>Accepts markup text.</li>", 
    dot.li("Renders nested DOT markup."),
    dot.li(
        dot.span("Has ") 
        + dot.span("toString() ") 
        + dot.span("overrides.")
    ),
    dot.li(function(){return "Accepts functions."}),
    function(){return dot.li("Is recursive.")},
    dot.li("<i>And more!</i>")
]);
}
				)
				.featuretutorial("Multi-line Events",
					dot.h("DOThmtl automatically renders inline function values for event attributes like <code>onclick</code> with named placeholders. The event handlers will be passed a standard JavaScript event argument. Try running this example mulitple times to get a feel for how it works."),
function(){
return dot.button("Try me.").id("multi-line-event-example").type("button")
.onclick(function(e){
    alert("You clicked " + e.target.id);
});
},
					dot.h("Many developers like to keep business logic separate from front end markup. That principal can be upheld with DOT syntax; just know that this technique is an option.")
				)
				.featuretutorial("Conditional Markup",
					dot.h("Here's another thing pure HTML can't do. <code>if(condition, callback).elseif(condition, callback).else(callback)</code>. Conditions are evaluated based on JavaScript truthiness where everything is true except for <code>false</code>, <code>0</code>, <code>\"\"</code>, <code>null</code>, <code>undefined</code>, and <code>NaN</code>."),
function(){
return dot.button("Rock Paper Scissors.").id("multi-line-event-example")
.onclick(function(e){
    rpsCounter = Math.random();
    dot("#rps-out").empty()
    .if(rpsCounter <= (1 / 3), "Rock!")
    .elseif(rpsCounter <= (2 / 3), "Paper!")
    .else("Scissors!");
})
.br()
.br()
.span("Click the button.").id("rps-out")
.style("border: 4px solid black; padding: 2px;");
},
					dot.h("Note that the <code>callback</code> parameter can be replaced with any DOThtml element building or attribute building object or function. New attributes will be added to the preceeding element.")
				)
				.featuretutorial("Iterative Markup",
					dot.h("There are two iterative page building functions. <code>each(array, callback)</code> will execute the function <code>callback(element)</code> once for each element in <code>array</code>, passing in the element as a parameter. <code>iterate(iterations, callback, params)</code> will call the function <code>callback(i, params)</code> where <code>i</code> is a 0-based integer representing the current iteration number, and <code>params</code> is optionally any JavaScript object or value that you'd like to have available inside the loop. <code>iterations</code> is the number of times to iterate.<br /><br />")
					.h("The return values of both page building functions are treated as page building objects and will be concatenated to the target as expected."),
function(){
return dot.ul(
    //Example 1: each
    dot.each(["apple", "banana", "orange", "mango"], function(fruit){
        return dot.li(fruit);
    })
    
    //Example 2: iterate
    .iterate(4, function(i, params){
        //Let's reverse the list for this demonstration.
        return dot.li(params[params.length - i - 1]);
    }, ["apple", "banana", "orange", "mango"])
);
}
				)
				.featuretutorial("Timed Markup",
					dot.h("The <code>wait(timeout, markup)</code> page building function creates an empty <code>&lt;x-dothtml-timeout&gt;</code> element as a placeholder, and replaces it with markup generated by the page building object <code>markup</code> after <code>timeout</code> milliseconds. The timer for nested timed elemnets starts immediately after the <code>wait</code> function is called, and doesn't wait for parent timed elements."),
function(){
return dot.ul(
    dot.li("START")
    .wait(1000, dot.li("one"))
    .wait(2000, dot.li("two"))
    .wait(3000, dot.li("three"))
    .wait(4000, dot.li(
        dot.ul(
            dot.li("four")
            .wait(5000, dot.li("five"))
        )
    ))
    .li("END")
) //Oh, and timed attributes can also be dropped.
.wait(6000, dot.style("color: red;")); 
},
					dot.h("<code>&lt;x-dothtml-timeout&gt;</code> is a custom element. Most browsers will treat it as an empty <code>&lt;span&gt;</code>, as per the <a href=\"https://www.w3.org/TR/html5/infrastructure.html#extensibility-0\" target=\"_blank\">W3C spec</a>.")
				)
				.featuretutorial("Custom Elements and Attributes",
					dot.h("At any time you can use the <code>el(name, markup)</code> and <code>attr(name, value)</code> to explicitly create a specific HTML element or attribute respectively, without relying on DOThtml's built-in page building functions."),
function(){
return dot.el("div", "This could be any HTML or custom element!")
.attr("style", "color: white; background-color:black; padding: 10px;");
},
					dot.h("This can be useful when defining custom elements and attributes, or when experimenting with elements and attributes supported in future versions of HTML that have not yet been implemented in DOThtml.")
				)
				.featuretutorial("Custom Widgets",
					dot.h("You can register a custom widget with <code>dot.createWidget(name, callback)</code> where <code>name</code> is the name of the widget that will be accissible from any DOThtml page building objects, and <code>callback</code> is your own custom page building function. The return value of your page building function should return a valid page building object derrived by chaining <code>dot</code>, otherwise your widget won't be chainable in the way that other dot components are. Here are a few examples."),
function(){
return dot.script(function(){
    //Using dot.script() allows us to run anonymous code in-line.
    //Normally widgets can be declared at the top of your code,
    //but the widget this website uses to print examples
    //will only display dot code. See the page source for more info.
    //There is virtually no difference between dot.script() and dot.h().

    //Here we define three widgets.

    //1. Widget that applies a custom style to the previous element.
    dot.createWidget("applyStyles", function(){
        //DOTcss is a pretty cool library too. No dependency on DOThtml.
        //Check it out.
        return dot.style(
            dotcss.color(
                Math.random() * 256, 
                Math.random() * 256, 
                Math.random() * 256));
    });

    //2. Widget that prints out each element in an array inside a custom
    //container. This is an improvement over DOThtml's native
    //array-joining functionality.
    //This widget is available in the DOThtml-ui library.
    dot.createWidget("wrappedList", function(array, wrapperBuilder){
        return dot.each(array, function(element){
            return wrapperBuilder(element);
        });
    });

    //3. This widget uses the previous two widgets to
    //generate a stylized ordered list from an array.
    dot.createWidget("stylizedOrderedList", function(array){
        return dot.ol(
            dot.wrappedList(array, function(element){
                return dot.li(element).applyStyles();
            })
        );
    })
})//We can now use them immediately. Just 1 Line of code!
.stylizedOrderedList(["Aye", "Bee", "Sea", "Di"]);
},
					dot.h("You can overwrite a previously-defined widget by calling createWidget again with the same widget name. Try to avoid overwritting built-in DOThtml functions or properties as this could render DOThtml unusable.")
				)
				.featuretutorial("JQuery Wrappers",
					dot.h("DOThtml is not a JQuery addon and does not have a mandatory dependency on JQuery. However, if JQuery is available you will be able to use several JQuery event and transition wrappers.").br().br()
					.h("Currently, the following JQuery functions are supported: <code>animate</code>, <code>css</code>, <code>empty</code>, <code>fadeIn</code>, <code>fadeOut</code>, <code>fadeTo</code>, <code>hide</code>, <code>show</code>.").br().br()
					.h("In addition, DOThtml supports the following JQuery events: <code>blur</code>, <code>change</code>, <code>click</code>, <code>dblclick</code>, <code>focus</code>, <code>focusin</code>, <code>focusout</code>, <code>hover</code>, <code>keydown</code>, <code>keypress</code>, <code>keyup</code>, <code>mousedown</code>, <code>mouseenter</code>, <code>mouseleave</code>, <code>mousemove</code>, <code>mouseout</code>, <code>mouseover</code>, <code>mouseup</code>, <code>one</code>, <code>resize</code>, <code>scroll</code>, <code>select</code>, <code>submit</code>. ").br().br()
					.h("JQuery wrappers behave like DOThtml attribuets. They get attached to the previous element. To use a wrapper, add a <code>$</code> character in front of the name, for instance: <code>dot.div().$animate(args)</code>. The usage and parameters of each wrapped function are exactly the same as specified in the JQuery documentation pages.").br().br()
					.h("The goal for DOThtml is to ultimately not be dependent on any external libraries. So in the future all of these functions will ideally become native in DOThtml."),
function(){
return dot.div().style(dotcss.width(100).height(100).backgroundColor(0x000000))
.wait(1000, function(){
    //Remember to use return in all DOT functions, or they won't work!
    return dot.$animate({width: 200, height: 200})
})
}
				)
			), 
			dot.tab("Plugins & Addons", "plugins",
				dot.h1("This documentation is not complete yet. Please check back later!")
			), 
			dot.tab("Browser Support", "support",
				dot.h1("This documentation is not complete yet. Please check back later!")
			), 
			dot.tab("Donate", "donate",
				dot.h1("This documentation is not complete yet. Please check back later!")
			)
		]
	)
).class("container");

/*.div(dot.h3(dot.i("Version 1.1")).style("color: #999")
	.h1("Features")
	.h2("First: let DOThtml know where to render.")
		.p(dot.h("Use ").code("dot.begin(\'body\')").h(" to render to the body (when the DOM is ready). Alternatively, you can use any other CSS selector to render markup elsewhere.").p("This (and all other DOThtml functions) return a chainable page builder."))
	.h2("Chain functions together to generate HTML.")
		.p("Each body element as well as attributes (392, combined) are wrapped as DOThtml functions that can be chained together.")
		.p("For instance, instead of ")
		.pre("&lt;div id=\"mydiv1\"&gt;Hello, World!&lt;/div&gt;\r\n&lt;div id=\"mydiv2\"&gt;Hello, Again!&lt;/div&gt;").class("prettyprint linenums")
		.p("you can use ")
		.pre(".div(\'Hello, World!\').id(\'mydiv1\')\r\n.div(\'Hello, Again!\').id(\'mydiv2\')").class("prettyprint linenums")
	.h2("Introducing HTML control flow.")
		.p("Ever desired an easy way to set up an HTML table with a loop, client side?")
		.pre([	".table(function(){",
				"	for(var i = 0; i < myArray.length; i++){",
				"		dot.tr(function(){",
				"			.td(myArray[i])",
				"		});",
				"})"].join("\r\n")).class("prettyprint linenums")
		.p("How about conditional rendering?")
		.pre([".br();",
		"if(user.isLoggedIn){",
		"	dot.p('Welcome, ' + user.name + '!')",
		"}",
		"else{",
		"	dot.a('Log In').href('./login/')",
		"}",
		"dot.br()"].join("\r\n")).class("prettyprint linenums")
	.h2("JQuery is a dependency, but it's also so much more.")
		.p("Leverage JQuery functions like <code>$.css()</code>, <code>$.show()</code>, <code>$.animate()</code>, etc, as well as handlers like <code>$.click()</code>, <code>$.hover()</code>, <code>$.keypress()</code>, <code>$.resize()</code>, <code>$.scroll()</code>, etc, to extend HTML in powerful ways while reducing code messiness, redundancy and file-size. There are currently 24 supported JQuery events, and 8 supported display helpers.")
		.p("To use the JQuery wrappers, just call them through the usual DOT chain while adding $ to the front. All the parameters are the same as they would be for their jquery counterparts. For instance:")
		.pre(["dot.span('Click me!').$click(function(event){",
		"	alert('You clicked it!');",
		"})"].join("\r\n")).class("prettyprint linenums")
	.h2("Want to render plain text or HTML?")
		.p("You can pass HTML into any tag function.")
		.pre("dot.p('Hello, &lt;b&gt;Bold World!&lt;/b&gt;')").class("prettyprint linenums")
		.p("Alternatively, you can use the <code>.h()</code> function to render HTML without any particular parent tag. There is also a <code>.t()</code> function that escapes all special HTML characters (kind of like <code>$.Text()</code>).")
	.h2("Render HTML after a timeout.")
		.p("A handly little helper function that waits for a timeout in milliseconds before rendering HTML: ")
		.pre(["dot.h('Hello,')",
		".wait(1000, function(){",
		"	dot.h('Future World')",
		"})"].join("\r\n")).class("prettyprint linenums")
	.h2("Widgets made easy.")
		.p("DOThtml is extensible. You can build reusable widgets.")
		.pre(["dot.robotface = function(id, color){",
			"	dot.div(function(){",
			"		DOT",
			"		.div().style('position: absolute; width: 10px; height: 10px; left: 10px; top: 10px; background-color: black')",
			"		.div().style('position: absolute; width: 10px; height: 10px; right: 10px; top: 10px; background-color: black')",
			"		.div().style('position: absolute; width: 48px; height: 5px; left: 8px; top: 48px; background-color: black')",
			"	}).id(id).style('position: relative; width: 64px; height: 64px; background-color: ' + color + '; display: inline-block');",
			"	return DOT;",
			"}",
			"",
			"dot.robotface('emoticon1', 'yellow')",
			".robotface('emoticon2', 'blue')",
			".robotface('emoticon3', 'green')",
			".robotface('emoticon4', 'red');"].join("\r\n")).class("prettyprint linenums")
		.br()
		.robotface("emoticon1", "yellow")
		.robotface("emoticon2", "blue")
		.robotface("emoticon3", "green")
		.robotface("emoticon4", "red")
	.h1("Special Notes")
	.h2("DOThtml is in beta.")
		.p("There are tons of new features I have ligned up for this framework, including HTML validation, and less-verbose element nesting (removing the necessity of including a <code>function(){}</code> parameter), and SVG support. The downside is that the framework will be changing. Complete documentation will be released when he framework is out of beta.")
	.h2("What about HTML attributes that have the same name as elements?")
		.p("There are 5 of these: cite, form, label, span, summary. Currently, DOThtml assumes you want to add an attribute to the last element if a single string parameter is provided to the correspondingly-named functions. Otherwise, a new element is created.")
	.h1("Download / Learn More")
		.a("Check out DOThtml's page on github to get early access.").href("https://github.com/JSideris/DOThtml").target("_blank")
).id("content");*/


</script>

<script type="text/javascript" src="run_prettify.js"></script>
</html>